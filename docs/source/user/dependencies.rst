.. _dependencies-label:

Registering Your Project's Dependencies with CPP
================================================

This page describes how to add dependencies to your project.  Let's start with
the harsh reality: CPP can only build a dependency if you provide it a means
of obtaining the source code.  Similarly, CPP can only find a dependency if
that dependency provides CMake packaging files or if a find recipe is
available.  As the C/C++ community writes better CMake-based build systems
(or better yet adopts CPP) we anticipate the need for writing find recipes to
drop considerably.  As for building a dependency we've striven to do it with
the absolute fewest amount of input possible; again, only by the community
writing better build systems will this remain as simple as possible.

Adding the Dependency
---------------------

There are two commands to add a dependency to your project
``cpp_find_dependency`` and ``cpp_find_or_build_dependency``.  The former is
simpler to use:

.. code-block:: cmake

   cpp_find_dependency(<name>)

This will look for the dependency with the provided name (CMake is unfortunately
case-sensitive so you'll have to get the case right; the community consensus is
that the name should be snake_case for whatever that's worth) if found the
components from that package will be available for use as dependencies for your
targets.  If it's not found configuration will abort.

``cpp_find_or_build_dependency`` behaves similarly except that it will
build the dependency if it is not found.  Consequentially in addition to the
name of the dependency it requires information about where to find the source
code.  For the common case that the source is hosted on the internet:

.. code-block::cmake

   cpp_find_or_build_dependency(<name> URL <url>)

will suffice in many cases.  If instead you wish to bundle the dependency's
source code with your project (or equivalently if an end-user wants to work
offline and they have the source code on disk) using ``PATH`` to tell CPP where
the source code is can be done like:

.. code-block::cmake

   cpp_find_or_build_dependency(<name> PATH <path>)

.  CPP provides a number of additional control knobs you can use to control
what constitutes a suitable dependency for your project.  These include
things such as the version of the dependency (``VERSION <version>``) and the
components you explicitly need (``COMPONENTS <comp1> <comp2> ...``) (well I
plan to let you anyways).  Consult :ref:`cpp_find_or_build_dependency-label`
for an up-to-date list of these knobs.

Adding Dependencies Hosted on GitHub
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

GitHub is one of the most popular sites to host open source software on.  You
may or may not know that it also provides a rich URL-based API for selecting the
branch and/or version as well as forwarding credentials.  CPP is aware of this
API.  Thus to get the most out of a GitHub based repo it is recommended that you
provide the URL as ``github.com/organization/repo`` and not point to a specific
branch, tag, or revision.

The GitHub URL-based API also allows for private repos to be accessed via
tokens.  Tokens should be generated by the end-user of your project and supplied
as input to CMake via the variable ``CPP_GITHUB_TOKEN``.  As the actual token is
a rather long hash it is recommended that end-users use a toolchain file so they
don't have to retype it on the command line each time.  Obviously the end-user
needs access to the private repository in order for this work.  Finally, it is
worth noting that the actual value of your token will reside purely within the
build files generated by CMake and will not be retained by CPP itself.  That
said, the token will be available as plain text in those build files (plain text
of the hash) and could conceivably be scraped by a malicious dependency.

Adding Virtual Dependencies
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Virtual dependencies are dependencies on an API and not a dependency on the
library implementing the API.  Typical examples are BLAS, LAPACK, and MPI.
If your project requires a specific implementation of a virtual dependency
(*e.g.*, you use extensions only found in BLAS provided by Intel's MKL) you
should use the standard ``cpp_find_dependency`` and
``cpp_find_or_build_dependency`` commands and look for the implementation and
not the API.  Otherwise you specify your project's dependency on the API via

.. code-block::cmake

   cpp_find_dependency(<name> VIRTUAL <impl1> <impl2> ...)

where ``<name>`` would be something like ``blas`` and the various ``<impl>``
would be acceptable implementations in the order of precedence.  The
``cpp_find_or_build_dependency`` variant also takes information for building one
particular implementation, *e.g.*,

.. code-block::cmake

   cpp_find_or_build_dependency(<name> VIRTUAL <impl1> <impl2>... URL <url>)

if the implementation is available on the internet.  Within your build system
you should refer to the dependency as ``<name>::<name>`` or
``<name>::<component>`` if the API defines components, where ``name`` is the
name of the API, not the implementation.


Tracking Transitive Dependencies
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The above use cases primarily are designed for situations where the dependencies
do not themselves have dependencies.  In these cases CPP does not have to worry
about transitively tracking the dependencies.  The other notable use case is
for dependencies that use CPP already.  CPP works transitively so it suffices to
use the above APIs in those cases.  For pretty much all other situations
(assuming you want CPP to manage transitive dependencies too) you likely need to
provide a build recipe.  A typical build recipe looks something like:

.. code-block::cmake

   include(ExternalProject) #Needed for ExternalProject_Add command

   #Find (or build) the dependency's dependencies...
   cpp_find_dependency(depend1)

   #Tell CPP how to build the project
   ExternalProject_Add(
       <name>
       [<options> ...]
   )

Basically you use the CPP ``find_dependency`` and ``find_or_build_dependecy``
commands to find all of the dependency's dependencies.  Generally speaking you
will then have to setup an ``ExternalProject_Add`` function call
(`API <https://cmake.org/cmake/help/latest/module/ExternalProject.html>`_) to
build the dependency.  Important to setting up this call you must forward the
paths to the dependency's dependencies manually.  In the event that the
dependency uses CMake it is possible to use CPP's ``find_or_build_dependency``
command and forward the paths through the ``CMAKE_ARGS`` option.  Once the
build recipe is written you add the dependency to your project via:

.. code-block::cmake

   cpp_find_or_build_dependency(<name> RECIPE <path2recipe>)

Tips for Writing Build Recipes
""""""""""""""""""""""""""""""

These are tips for writing build recipes collected over time and in no specific
order.

* As a means of convention we recommend putting your project's build recipes in
  ``root/cmake/build_recipes`` where ``root`` is the root of your project.
* Only use the ``BUILD_COMMAND`` and ``INSTALL_COMMAND`` options as a last
  resort.  Particularly when the project uses GNU make (either because it's an
  Autotools project or because that's the selected CMake backend) CMake knows
  how to build/install it better than you do.
* Build recipes that are written in a generic fashion are of use to the
  community and should be contributed back so others do not have to write them.
  * Mechanism for how to do this is forthcoming...

Writing Find Recipes
--------------------

When a dependency does not provide a set of CMake config files it becomes
necessary to write a find recipe for that project (equivalently if the config
files do not adhere to usual CMake norms it may be necessary to write find
files.  This section details the best practices for doing this.
